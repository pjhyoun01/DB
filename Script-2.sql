
---- 추가 문제
-- 1. 부서아이디별 사원의 평균연봉을 조회한다. 12
SELECT AVG(SALARY) AS DEPT_AVG_SALARY
  FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID 
;
-- 2. 직무아이디별 사원의 최고연봉을 조회한다. 19
SELECT MAX_SALARY 
  FROM JOBS
;
-- 3. 인센티브를 안받는 사원의 모든 정보를 조회한다. 35
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NOT NULL
;
-- 4. 인센티브를 받는 사원의 부서아이디를 중복없이 조회한다. 1
SELECT DISTINCT DEPARTMENT_ID 
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
   AND COMMISSION_PCT IS NOT NULL
;
-- 5. 인센티브를 받는 사원의 직무아이디를 중복없이 조회한다. 2
SELECT DISTINCT JOB_ID 
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
   AND COMMISSION_PCT IS NOT NULL
;
-- 6. 사원이 있는 부서의 지역아이디를 조회한다. 11
SELECT LOCATION_ID 
  FROM DEPARTMENTS
 WHERE DEPARTMENT_ID IN (SELECT DISTINCT DEPARTMENT_ID 
 						  FROM EMPLOYEES
 						 WHERE EMPLOYEE_ID IS NOT NULL)
;
-- 7. Seattle에 존재하는 부서번호를 조회한다. 21
SELECT DEPARTMENT_ID
  FROM DEPARTMENTS
 WHERE LOCATION_ID = (SELECT LOCATION_ID
 						FROM LOCATIONS
 					   WHERE CITY = 'Seattle')
;
-- 8. 사원이 한명도 없는 도시를 조회한다. 16
SELECT CITY
  FROM LOCATIONS
 WHERE LOCATION_ID NOT IN (SELECT LOCATION_ID 
 							 FROM DEPARTMENTS
 					   		WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
 					   								  FROM EMPLOYEES))
;
-- 9. 사원이 한명이라도 있는 도시를 조회한다. 7
SELECT CITY
  FROM LOCATIONS
 WHERE LOCATION_ID IN (SELECT LOCATION_ID 
 						 FROM DEPARTMENTS
 					   	WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
 					   							  FROM EMPLOYEES))
;
-- 10. 모든 사원의 정보를 연봉으로 오름차순 정렬하여 조회한다. 107
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 ORDER BY SALARY
;
-- 11. 모든 사원의 사원번호, 이름, 성, 연봉, 인센티브를 포함한 연봉 정보를 조회한다. 107
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , SALARY
	 , CASE WHEN COMMISSION_PCT IS NULL THEN SALARY
	   ELSE ((SALARY * COMMISSION_PCT) + SALARY) END AS "인센티브 연봉"
  FROM EMPLOYEES
;
-- 12. 2003년에 입사한 사원은 몇 명인지 조회한다. 1
SELECT COUNT(EMPLOYEE_ID)
  FROM EMPLOYEES
 WHERE HIRE_DATE BETWEEN TO_DATE('20030101', 'YYYY-MM-DD') AND TO_DATE('20031231', 'YYYY-MM-DD')
;
-- 13. 113번 사원의 상사의 모든 정보를 조회한다. 1
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE EMPLOYEE_ID = (SELECT MANAGER_ID 
 						FROM EMPLOYEES
 					   WHERE EMPLOYEE_ID = 113)
;
-- 14. 모든 부서의 부서장의 모든 사원 정보를 조회한다. 11
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE EMPLOYEE_ID IN (SELECT MANAGER_ID
 						FROM DEPARTMENTS)
;
-- 15. 사원의 이름이 7자리인 사원의 모든 정보를 조회한다. 23
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES 
 WHERE FIRST_NAME LIKE '_______'
;
-- 16. 사원의 이메일이 6자리인 사원의 모든 정보를 조회한다. 25
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES 
 WHERE EMAIL LIKE '______'
;

--최고 월급을 받는 사원들의 사원 번호와 월급 조회
SELECT E.EMPLOYEE_ID 
	 , E.SALARY 
  FROM EMPLOYEES E
 WHERE E.SALARY = (SELECT MAX(SALARY)
 					 FROM EMPLOYEES)	
;
-- 평균 월급보다 적게 받는 사원들의 사원번호와 월급 조회

-- 1. 현재 시간을 조회한다.
SELECT SYSDATE AS "현재 시간"
	 , SYSDATE - 1 AS "하루 전"
	 , SYSDATE - 3 / 24 AS "3시간 전"
	 , SYSDATE - 15 / 24 / 60 AS "15분 전"
	 , SYSDATE + 50 / 24 / 60 / 60 AS "50초 후"
	 , ADD_MONTHS(SYSDATE, 1) AS "한달 후"
  FROM DUAL
;
-- 2. 현재 시간을 "연-월-일" 포멧으로 조회한다.
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') "연월일"
	 , TO_CHAR(SYSDATE, 'YYYY') AS "년도"
	 , TO_CHAR(SYSDATE, 'MM') AS "월"
	 , TO_CHAR(SYSDATE, 'DD') AS "일"
	 , TO_CHAR(SYSDATE, 'HH24') AS "일24"
	 , TO_CHAR(SYSDATE, 'MI') AS "분"
	 , TO_CHAR(SYSDATE, 'SS') AS "초"
  FROM DUAL
;
-- 3. 한 시간 전 시간을 "시:분:초" 포멧으로 조회한다.
SELECT TO_CHAR(SYSDATE - 1 / 24, 'YYYY:MM:DD') AS "1 Hour Befor"
  FROM DUAL
;
-- 2월 12일 연습문제
-- '2026-02-12' 텍스트를 날짜타입으로 변경한다.
SELECT TO_DATE('2026-02-12', 'YYYY-MM-DD')
-- '2026-02-12' 기준으로 50일 이후 날짜와 시간을 조회한다.
	 , TO_DATE('2026-02-12', 'YYYY-MM-DD') + 50
-- '2026-02-13' 기준으로 3시간 이후의 날짜와 시간을 조회한다.
	 , TO_DATE('2026-02-12', 'YYYY-MM-DD') + 3 / 24
-- '2026-02-12' 기준으로 1일 후의 날짜만 조회한다.
	 , TO_CHAR((TO_DATE('2026-02-12', 'YYYY-MM-DD') + 1), 'YYYY-MM-DD')
-- '2026-02-12' 기준으로 3일 후의 날짜와 시만 조회한다.
	 , TO_CHAR((TO_DATE('2026-02-12', 'YYYY-MM-DD') + 3), 'YYYY-MM-DD HH')
  FROM DUAL
;
-- 4. EMPLOYEES 테이블의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
;  
-- 5. DEPARTMENTS 테이블의 모든 정보를 조회한다.
SELECT DEPARTMENT_ID
	 , DEPARTMENT_NAME
	 , MANAGER_ID
	 , LOCATION_ID
  FROM DEPARTMENTS
;
-- 6. JOBS 테이블의 모든 정보를 조회한다.
SELECT JOB_ID
	 , JOB_TITLE
	 , MIN_SALARY
	 , MAX_SALARY
  FROM JOBS
;
-- 7. LOCATIONS 테이블의 모든 정보를 조회한다.
SELECT LOCATION_ID
	 , STREET_ADDRESS
	 , POSTAL_CODE
	 , CITY
	 , STATE_PROVINCE
	 , COUNTRY_ID
  FROM LOCATIONS
;
-- 8. COUNTRIES 테이블의 모든 정보를 조회한다.
SELECT COUNTRY_ID
	 , COUNTRY_NAME
	 , REGION_ID
  FROM COUNTRIES
;
-- 9. REGIONS 테이블의 모든 정보를 조회한다.
SELECT REGION_ID
	 , REGION_NAME
  FROM REGIONS
;
-- 10. JOB_HISTORY 테이블의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , START_DATE
	 , END_DATE
	 , JOB_ID
	 , DEPARTMENT_ID
  FROM JOB_HISTORY
;
-- 11. 90번 부서에서 근무하는 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.DEPARTMENT_ID = 90
;
-- 12. 90번, 100번 부서에서 근무하는 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.DEPARTMENT_ID = 90
    OR E.DEPARTMENT_ID = 100
;
-- 13. 100번 상사의 직속 부하직원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.MANAGER_ID = 100
;
-- 14. 직무 아이디가 AD_VP 인 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.JOB_ID = 'AD_VP'
;
-- 15. 월급이 7000 이상인 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.SALARY > 7000
;
-- 16. 2005년 09월에 입사한 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE TO_CHAR(E.HIRE_DATE, 'YYYY-MM')= '2005-09'
;
-- 17. 111번 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.EMPLOYEE_ID = 111
;
-- 18. 인센티브를 안받는 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.COMMISSION_PCT IS NULL
;
-- 19. 인센티브를 받는 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.COMMISSION_PCT IS NOT NULL
;
-- 20. 이름의 첫 글자가 'D' 인 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.FIRST_NAME LIKE 'D%'
;
-- 21. 성의 마지막 글자가 'a' 인 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.LAST_NAME LIKE '%a'
;
-- 22. 전화번호에 '.124.'이 포함된 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.PHONE_NUMBER LIKE '%.124.%'
;
-- 23. 직무 아이디가 'PU_CLERK'인 사원 중 월급이 3000 이상인 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.JOB_ID = 'PU_CLERK'
   AND E.SALARY >= 3000
;
-- 24. 평균 월급보다 많이 받는 사원들의 사원번호, 이름, 성, 월급을 조회한다.
SELECT E.EMPLOYEE_ID 
	 , E.FIRST_NAME 
	 , E.LAST_NAME 
	 , E.SALARY 
  FROM EMPLOYEES E
 WHERE E.SALARY > (SELECT AVG(E2.SALARY)
 					FROM EMPLOYEES E2)
;
-- 25. 평균 월급보다 적게 받는 사원들의 사원번호, 월급, 부서번호를 조회한다.
SELECT E.EMPLOYEE_ID 
	 , E.SALARY 
	 , E.DEPARTMENT_ID 
  FROM EMPLOYEES E
 WHERE E.SALARY < (SELECT AVG(E2.SALARY)
 					FROM EMPLOYEES E2)
;
-- 26. 가장 많은 월급을 받는 사원의 사원번호, 이름, 월급을 조회한다.
SELECT E.EMPLOYEE_ID 
	 , CONCAT(E.FIRST_NAME, E.LAST_NAME) AS NAME
	 , E.SALARY 
  FROM EMPLOYEES E
 WHERE E.SALARY = (SELECT MAX(EM.SALARY)
 					FROM EMPLOYEES EM)
;
-- 27. 이름이 4글자인 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
-- WHERE LENGTH(E.FIRST_NAME) = 4
 WHERE E.FIRST_NAME LIKE '____'
;
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE LENGTH(E.FIRST_NAME) >= 4
-- WHERE E.FIRST_NAME LIKE '____%'
;
-- 28. 'SA_REP' 직무인 직원 중 가장 높은 월급과 가장 낮은 월급을 조회한다.
SELECT MAX(E.SALARY)
	 , MIN(E.SALARY)
  FROM EMPLOYEES E
 WHERE E.JOB_ID LIKE 'SA_REP'
-- WHERE E.JOB_ID = 'SA_REP'
 ;
-- 29. 직원의 입사일자를 '연-월-일' 형태로 조회한다.
SELECT TO_CHAR(E.HIRE_DATE)
  FROM EMPLOYEES E
;
-- 30. 가장 늦게 입사한 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.HIRE_DATE = (SELECT MAX(E2.HIRE_DATE)
 						FROM EMPLOYEES E2)
;
-- 31. 가장 일찍 입사한 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.HIRE_DATE = (SELECT MIN(E2.HIRE_DATE)
 						FROM EMPLOYEES E2)
;
-- 32. 자신의 상사보다 더 많은 월급을 받는 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID 
	 , E.MANAGER_ID 
	 , E.SALARY AS 본인월급
	 , E2.SALARY AS 상사월급
  FROM EMPLOYEES E
  LEFT OUTER JOIN EMPLOYEES E2
    ON E.MANAGER_ID = E2.EMPLOYEE_ID 
 WHERE E.SALARY > E2.SALARY 
;
-- 33. 자신의 상사보다 더 일찍 입사한 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
	 , E2.HIRE_DATE 
  FROM EMPLOYEES E
  LEFT OUTER JOIN EMPLOYEES E2
    ON E.MANAGER_ID = E2.EMPLOYEE_ID
 WHERE E.HIRE_DATE < E2.HIRE_DATE 
;
SELECT *
  FROM EMPLOYEES E
 WHERE HIRE_DATE < (SELECT HIRE_DATE
 					  FROM EMPLOYEES E2
 					 WHERE E.MANAGER_ID = E2.EMPLOYEE_ID)
;
-- 34. 부서아이디별 평균 월급을 조회한다.
SELECT E.DEPARTMENT_ID 
	 , AVG(E.SALARY)
  FROM EMPLOYEES E
 WHERE E.DEPARTMENT_ID IS NOT NULL
 GROUP BY E.DEPARTMENT_ID
  
;
-- 35. 직무아이디별 평균 월급, 최고월급, 최저월급을 조회한다.
SELECT E.JOB_ID 
	 , AVG(E.SALARY ) AS "평균 월급"
	 , MAX(E.SALARY ) AS "최고 월급"
	 , MIN(E.SALARY ) AS "최저 월급"
  FROM EMPLOYEES E
 GROUP BY E.JOB_ID 
; 
-- 36. 가장 많은 인센티브를 받는 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.COMMISSION_PCT = (SELECT MAX(E2.COMMISSION_PCT)
 							 FROM EMPLOYEES E2)

;
-- 37. 가장 적은 인센티브를 받는 사원의 월급과 인센티브를 조회한다.
SELECT E.SALARY 
	 , E.COMMISSION_PCT
  FROM EMPLOYEES E
 WHERE E.COMMISSION_PCT = (SELECT MIN(E2.COMMISSION_PCT)
 							 FROM EMPLOYEES E2)
;
-- 38. 직무아이디별 사원의 수를 조회한다.
SELECT E.JOB_ID 
	 , COUNT(1)
  FROM EMPLOYEES E
 GROUP BY E.JOB_ID
;
-- 39. 상사아이디별 부하직원의 수를 조회한다. 단, 부하직원이 2명 이하인 경우는 제외한다.
SELECT COUNT(1)
  FROM EMPLOYEES E
  LEFT OUTER JOIN EMPLOYEES E2
    ON E.EMPLOYEE_ID = E2.EMPLOYEE_ID
 WHERE E.MANAGER_ID IS NOT NULL
 GROUP BY E.MANAGER_ID
HAVING COUNT(1) > 2
;
-- 40. 사원이 속한 부서의 평균월급보다 적게 받는 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE SALARY < (SELECT AVG(SALARY)
				   FROM EMPLOYEES E2
				  WHERE E.DEPARTMENT_ID = E2.DEPARTMENT_ID 
				  GROUP BY DEPARTMENT_ID)
;
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
	 , ROUND(E2.AVG_SALARY) AS "부서 평균"
  FROM EMPLOYEES E
  INNER JOIN (SELECT DEPARTMENT_ID 
  				   , AVG(SALARY) AVG_SALARY
  				FROM EMPLOYEES
  			   GROUP BY DEPARTMENT_ID) E2
  	 ON E.DEPARTMENT_ID = E2.DEPARTMENT_ID 
 WHERE E.SALARY < E2.AVG_SALARY
;
-- 41. 사원이 근무하는 부서명, 이름, 성을 조회한다.
SELECT D.DEPARTMENT_NAME 
	 , E.FIRST_NAME 
	 , E.LAST_NAME 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
;
-- 42. 가장 적은 월급을 받는 사원의 부서명, 이름, 성, 월급, 부서장사원번호를 조회한다.
SELECT D.DEPARTMENT_NAME 
	 , E.FIRST_NAME 
	 , E.LAST_NAME 
	 , D.MANAGER_ID 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 WHERE E.SALARY = (SELECT MIN(E2.SALARY)
 					 FROM EMPLOYEES E2)
;
-- 43. 상사사원번호를 중복없이 조회한다.
SELECT DISTINCT MANAGER_ID 
  FROM EMPLOYEES
 WHERE MANAGER_ID IS NOT NULL
;
-- 44. 50번 부서의 부서장의 이름, 성, 월급을 조회한다.
SELECT E.FIRST_NAME 
	 , E.LAST_NAME 
	 , E.SALARY 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 WHERE D.DEPARTMENT_ID = 50
   AND E.EMPLOYEE_ID = D.MANAGER_ID
;
-- 45. 부서명별 사원의 수를 조회한다.
SELECT D.DEPARTMENT_NAME 
	 , COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_NAME
;
-- 46. 사원의 수가 가장 많은 부서명, 사원의 수를 조회한다.
SELECT MAX(COUNT(E.EMPLOYEE_ID)) AS EMP_COUNT
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_NAME
;
SELECT D.DEPARTMENT_NAME 
	 , COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_NAME
 ORDER BY COUNT(E.EMPLOYEE_ID) DESC
 FETCH FIRST 1 ROWS ONLY
;
SELECT MDEC.DEPARTMENT_NAME 
	 , MDEC.EMP_COUNT
  FROM (SELECT D.DEPARTMENT_NAME 
			 , COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
		  FROM EMPLOYEES E
		 INNER JOIN DEPARTMENTS D
		    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
		 GROUP BY D.DEPARTMENT_NAME
		 ORDER BY EMP_COUNT DESC) MDEC
 WHERE ROWNUM = 1
;
-- 47. 사원이 없는 부서명을 조회한다.
SELECT D.DEPARTMENT_NAME
  FROM DEPARTMENTS D
  LEFT OUTER JOIN EMPLOYEES E
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 WHERE E.EMPLOYEE_ID IS NULL
;

SELECT DEPARTMENT_NAME
  FROM DEPARTMENTS
 WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT E.DEPARTMENT_ID 
 					 	   	   FROM EMPLOYEES E
 					 	  	  WHERE E.DEPARTMENT_ID IS NOT NULL)
;
-- 48. 직무가 변경된 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID 
 						 FROM JOB_HISTORY)
;
-- 49. 직무가 변경된적 없는 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID 
 						     FROM JOB_HISTORY)
;
-- 50. 직무가 변경된 사원의 과거 직무명과 현재 직무명을 조회한다.
SELECT E.FIRST_NAME 
	 , JH.JOB_TITLE  AS PREV_JOB
	 , TO_CHAR(JH.END_DATE, 'YYYY-MM-dd') AS END_DATE
	 , E.JOB_TITLE  AS CHANGE_JOB
  FROM (SELECT J.JOB_TITLE 
  			 , JH.END_DATE 
  			 , JH.EMPLOYEE_ID 
		  FROM JOB_HISTORY JH
		 INNER JOIN JOBS J
			ON JH.JOB_ID = J.JOB_ID) JH
  LEFT OUTER JOIN (SELECT E.FIRST_NAME 
  						, J.JOB_TITLE 
  						, E.EMPLOYEE_ID 
  					 FROM EMPLOYEES E
  					INNER JOIN JOBS J
  					   ON E.JOB_ID = J.JOB_ID)E
    ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID 
 ORDER BY E.FIRST_NAME
     , JH.END_DATE 
;
-- 51. 직무가 가장 많이 변경된 부서의 이름을 조회한다.
SELECT D.DEPARTMENT_NAME
	 , D.DEPARTMENT_ID
	 , JH.DEPT_COUNT
  FROM DEPARTMENTS D 
 INNER JOIN (SELECT D.DEPARTMENT_ID
			 	  , COUNT(D.DEPARTMENT_ID) AS DEPT_COUNT
			   FROM JOB_HISTORY JH
			  INNER JOIN DEPARTMENTS D
			     ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID 
			  GROUP BY D.DEPARTMENT_ID
			  ORDER BY COUNT(D.DEPARTMENT_ID) DESC) JH
	ON D.DEPARTMENT_ID = JH.DEPARTMENT_ID
 WHERE JH.DEPT_COUNT = 2
-- 이거 말고 어떻게 풀지 생각해보기
;         
SELECT MDEC.DEPARTMENT_NAME 
	 , MDEC.EMP_COUNT
  FROM (SELECT D.DEPARTMENT_NAME 
			 , COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
		  FROM EMPLOYEES E
		 INNER JOIN DEPARTMENTS D
		    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
		 GROUP BY D.DEPARTMENT_NAME
		 ORDER BY EMP_COUNT DESC) MDEC
 WHERE ROWNUM = 1
;
-- 직무 변경 횟수
--SELECT JH.DEPARTMENT_ID 
--	 , COUNT(JH.DEPARTMENT_ID)
--  FROM JOB_HISTORY JH
-- GROUP BY JH.DEPARTMENT_ID 
--;
-- 부서의 이름
--SELECT D.DEPARTMENT_NAME
--	 , D.DEPARTMENT_ID
--  FROM DEPARTMENTS D
--;
-- 52. 'Seattle' 에서 근무중인 사원의 이름, 성, 월급, 부서명 을 조회한다.
SELECT E.LAST_NAME 
	 , E.FIRST_NAME 
	 , E.SALARY
	 , D.DEPARTMENT_NAME 
	 , L.CITY 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
	ON D.LOCATION_ID = L.LOCATION_ID
 WHERE L.CITY = 'Seattle'
;
-- 53. 'Seattle' 에서 근무하지 않는 모든 사원의 이름, 성, 월급, 부서명, 도시를 조회한다.
SELECT E.LAST_NAME 
	 , E.FIRST_NAME 
	 , E.SALARY
	 , D.DEPARTMENT_NAME 
	 , L.CITY 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
	ON D.LOCATION_ID = L.LOCATION_ID
-- WHERE L.CITY != 'Seattle'
 WHERE L.CITY NOT IN 'Seattle'
;
-- 54. 근무중인 사원이 가장 많은 도시와 사원의 수를 조회한다.  
SELECT MAX(COUNT(E.EMPLOYEE_ID)) AS MAX_CITY_VALUE
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
	ON D.LOCATION_ID = L.LOCATION_ID
 GROUP BY L.CITY 
;
-- 55. 근무중인 사원이 없는 도시를 조회한다.
SELECT *
  FROM LOCATIONS L
  LEFT JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID
  LEFT JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
;
SELECT *
  FROM EMPLOYEES E
  LEFT JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
  LEFT JOIN LOCATIONS L
	ON D.LOCATION_ID = L.LOCATION_ID
;
-- 56. 월급이 7000 에서 12000 사이인 사원이 근무중인 도시를 조회한다.
SELECT DISTINCT L.CITY
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L 
    ON D.LOCATION_ID = L.LOCATION_ID
 WHERE E.SALARY BETWEEN 7000 AND 12000
;
-- 잘못된 코드
--SELECT DISTINCT(L.CITY)
--  FROM LOCATIONS L
-- RIGHT OUTER JOIN DEPARTMENTS D
--    ON L.LOCATION_ID = D.LOCATION_ID
-- RIGHT OUTER JOIN (SELECT * 
-- 					 FROM EMPLOYEES
-- 					WHERE SALARY BETWEEN 7000 AND 12000) E
-- 	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
-- WHERE L.CITY IS NOT NULL
--;
-- 57. 'Seattle' 에서 근무중인 사원의 직무명을 중복없이 조회한다.
SELECT DISTINCT(J.JOB_TITLE)
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID 
 WHERE L.CITY = 'Seattle'
;
-- 58. 사내의 최고월급과 최저월급의 차이를 조회한다.
SELECT MAX(E.SALARY) AS MAXSAL
	 , MIN(E.SALARY) AS MINSAL
	 , (MAX(E.SALARY) - MIN(E.SALARY)) AS SUB_MAXSAL_MINSAL
  FROM EMPLOYEES E 
;
-- 59. 이름이 'Renske' 인 사원의 월급과 같은 월급을 받는 사원의 모든 정보를 조회한다. 단, 'Renske' 사원은 조회에서 제외한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE SALARY = (SELECT SALARY 
		  		     FROM EMPLOYEES
		  		    WHERE FIRST_NAME = 'Renske')
   AND FIRST_NAME != 'Renske'
;
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.SALARY = (SELECT SALARY 
		  		     FROM EMPLOYEES
		  		    WHERE FIRST_NAME = 'Renske')
;
-- 60. 회사 전체의 평균 월급보다 많이 받는 사원들 중 이름에 'u' 가 포함된 사원과 동일한 부서에서 근무중인 사원들의 모든 정보를 조회한다.
-- 평균 월급 6461.8
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE DEPARTMENT_ID IN (SELECT DISTINCT DEPARTMENT_ID
						   FROM EMPLOYEES
						  WHERE SALARY > (SELECT AVG(SALARY)
											FROM EMPLOYEES))
							AND (FIRST_NAME LIKE '%u%'
							 OR FIRST_NAME LIKE '%U%')
;
-- 61. 부서가 없는 국가명을 조회한다.
SELECT COUNTRY_NAME 
  FROM COUNTRIES
 WHERE COUNTRY_ID IN (SELECT COUNTRY_ID
					    FROM LOCATIONS
 					   WHERE LOCATION_ID NOT IN (SELECT LOCATION_ID 
 					  						 	   FROM DEPARTMENTS))
;
SELECT C.COUNTRY_NAME 
  FROM COUNTRIES C
  LEFT OUTER JOIN LOCATIONS L
    ON C.COUNTRY_ID = L.COUNTRY_ID
  LEFT OUTER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID
 WHERE D.DEPARTMENT_ID IS NULL
 
;
    

-- 62. 'Europe' 에서 근무중인 사원들의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
	 , R.REGION_NAME 
  FROM EMPLOYEES E
  LEFT OUTER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
  LEFT OUTER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
  LEFT OUTER JOIN COUNTRIES C
    ON L.COUNTRY_ID = C.COUNTRY_ID
  LEFT OUTER JOIN REGIONS R
    ON C.REGION_ID = R.REGION_ID
 WHERE R.REGION_NAME = 'Europe'
;
-- ================================================================
-- 다시 풀기
-- 63. 'Europe' 에서 가장 많은 사원들이 있는 부서명을 조회한다.
--SELECT COUNT(D.DEPARTMENT_NAME)
----	 , D.DEPARTMENT_NAME  
--  FROM EMPLOYEES E
--  LEFT OUTER JOIN DEPARTMENTS D
--    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
--  LEFT OUTER JOIN LOCATIONS L
--    ON D.LOCATION_ID = L.LOCATION_ID
--  LEFT OUTER JOIN COUNTRIES C
--    ON L.COUNTRY_ID = C.COUNTRY_ID
--  LEFT OUTER JOIN REGIONS R
--    ON C.REGION_ID = R.REGION_ID
-- WHERE R.REGION_NAME = 'Europe'
---- GROUP BY E.DEPARTMENT_ID
--;
-- 64. 대륙 별 사원의 수를 조회한다.
SELECT COUNT(E.EMPLOYEE_ID)
  FROM EMPLOYEES E
  LEFT OUTER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
  LEFT OUTER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
  LEFT OUTER JOIN COUNTRIES C
    ON L.COUNTRY_ID = C.COUNTRY_ID
  LEFT OUTER JOIN REGIONS R
    ON C.REGION_ID = R.REGION_ID
 WHERE R.REGION_ID IS NOT NULL
 GROUP BY R.REGION_ID 
;
-- 65. 월급이 2500, 3500, 7000 이 아니며 직업이 SA_REP 이나 ST_CLERK 인 사람들을 조회한다.
SELECT SALARY 
	 , JOB_ID 
  FROM EMPLOYEES 
 WHERE SALARY != 2500
   AND SALARY != 3500
   AND SALARY != 7000
   AND (JOB_ID = 'SA_REP'
    OR JOB_ID = 'ST_CLERK')
;
SELECT EMPLOYEE_ID 
	 , SALARY 
  FROM EMPLOYEES 
 WHERE SALARY NOT IN (2500, 3500, 7000)
;
SELECT SALARY 
	 , JOB_ID 
  FROM EMPLOYEES 
 WHERE JOB_ID IN('SA_REP','ST_CLERK')
;
SELECT EMPLOYEE_ID 
	 , SALARY 
  FROM EMPLOYEES 
 WHERE SALARY NOT IN (2500, 3500, 7000)
   AND JOB_ID IN('SA_REP','ST_CLERK')
;
-- 66. 사원의 사원번호, 이름, 성, 상사의 사원번호, 상사의 이름, 상사의 성을 조회한다.
SELECT E.EMPLOYEE_ID 
	 , E.FIRST_NAME 
	 , E.LAST_NAME 
	 , E2.EMPLOYEE_ID
	 , E2.FIRST_NAME 
	 , E2.LAST_NAME 
  FROM EMPLOYEES E
 INNER JOIN EMPLOYEES E2 
	ON E.MANAGER_ID = E2.EMPLOYEE_ID
;
-- 67. 101번 사원의 모든 부하직원 들의 이름, 성, 상사사원번호, 상사사원명을 조회한다.
SELECT E.FIRST_NAME 
	 , E.LAST_NAME
	 , E2.EMPLOYEE_ID 
	 , CONCAT(E2.FIRST_NAME, E2.LAST_NAME) AS MANAGER_NAME
  FROM EMPLOYEES E
 INNER JOIN EMPLOYEES E2
    ON E.MANAGER_ID = E2.EMPLOYEE_ID 
 WHERE E.MANAGER_ID = 101
;
-- 68. 114번 직원의 모든 상사들의 이름, 성, 상사사원번호, 상사사원명을 조회한다.
 SELECT E.FIRST_NAME 
	  , E.LAST_NAME 
	  , E2.FIRST_NAME AS MANAGER_FIRST_NAME
	  , E2.LAST_NAME AS MANAGER_LAST_NAME
   FROM EMPLOYEES E
  INNER JOIN EMPLOYEES E2
     ON E.MANAGER_ID = E2.EMPLOYEE_ID
  START WITH E.EMPLOYEE_ID = 114
CONNECT BY PRIOR E.MANAGER_ID = E.EMPLOYEE_ID
    
;
-- 69. 114번 직원의 모든 상사들의 이름, 성, 상사사원번호, 상사사원명을 조회한다. 단, 역순으로 조회한다.
-- 역순이 부하직원을 구하는 건지
-- ORDER BY를 하는건지 파악하기
 SELECT E.FIRST_NAME 
	  , E.LAST_NAME 
	  , E2.FIRST_NAME AS MANAGER_FIRST_NAME
	  , E2.LAST_NAME AS MANAGER_LAST_NAME
   FROM EMPLOYEES E
  INNER JOIN EMPLOYEES E2
     ON E.MANAGER_ID = E2.EMPLOYEE_ID
  START WITH E.EMPLOYEE_ID = 114
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID 
;
-- 70. 모든 사원들을 정보를 월급 오름차순 정렬하여 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 ORDER BY E.SALARY ASC 
;
-- 71. 모든 사원들을 이름 내림차순 정렬하여 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 ORDER BY E.LAST_NAME DESC 
;
-- 72. 모든 사원들의 이름, 성, 월급, 부서명을 부서번호로 내림차순 정렬하여 조회한다.
SELECT E.LAST_NAME 
	 , E.FIRST_NAME 
	 , E.SALARY 
	 , D.DEPARTMENT_NAME 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 ORDER BY E.DEPARTMENT_ID DESC
;
-- 73. 부서명별 월급의 합을 내림차순 정렬하여 조회한다.
SELECT D.DEPARTMENT_NAME
	 , S.SALARY_SUM
  FROM DEPARTMENTS D
 INNER JOIN (SELECT DEPARTMENT_ID
 				, COUNT(SALARY) AS SALARY_SUM
 			 FROM EMPLOYEES
 			WHERE DEPARTMENT_ID IS NOT NULL
 			GROUP BY DEPARTMENT_ID) S
 	ON D.DEPARTMENT_ID = S.DEPARTMENT_ID
 ORDER BY S.SALARY_SUM DESC
;
-- 74. 직무명별 사원의 수를 오름차순 정렬하여 조회한다.
SELECT J.JOB_TITLE 
	 , COUNT(J.JOB_TITLE ) AS EMP_COUNT
  FROM EMPLOYEES E
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID
 GROUP BY J.JOB_TITLE 
;
-- 75. 모든 사원들의 모든 정보를 조회한다. 단, 인센티브를 받는 사원은 "인센티브여부" 컬럼에 "Y"를, 아닌 경우 "N"으로 조회한다.
SELECT CASE WHEN E.COMMISSION_PCT IS NULL THEN E.SALARY 
	   ELSE 'Y' END AS 인센티브여부
	 , E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 ;
-- 76. 모든 사원들의 이름을 10자리로 맞추어 조회한다.
SELECT SUBSTR(CONCAT(E.FIRST_NAME, E.LAST_NAME), 1, 10)
  FROM EMPLOYEES E
;
-- 77. 2007년에 직무가 변경된 사원들의 현재 직무명, 부서명, 사원번호, 이름, 성을 조회한다.
SELECT J.JOB_TITLE 
	 , D.DEPARTMENT_NAME 
	 , E.EMPLOYEE_ID 
	 , E.FIRST_NAME 
	 , E.LAST_NAME
  FROM EMPLOYEES E
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID
 INNER JOIN JOB_HISTORY JH
    ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 WHERE TO_CHAR(JH.START_DATE, 'YYYY') = '2007' 
;
-- 78. 직무별 최대월급보다 더 많은 월급을 받는 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE SALARY > (SELECT MAX_SALARY 
 					 FROM JOBS J
 					WHERE E.JOB_ID = J.JOB_ID) 
;
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE SALARY > ANY (SELECT MAX_SALARY 
 					   FROM JOBS J) 
;
SELECT DISTINCT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
  INNER JOIN JOBS J 
    ON E.SALARY > J.MAX_SALARY
;
-- 79. 사원들의 입사일자 중 이름, 성, 연도만 조회한다.
SELECT E.FIRST_NAME 
	 , E.LAST_NAME 
	 , TO_CHAR(E.HIRE_DATE, 'YYYY')
  FROM EMPLOYEES E
;

-- 80. 사원들의 입사일자 중 이름, 성, 연도, 월 만 조회한다.
SELECT E.FIRST_NAME 
	 , E.LAST_NAME 
	 , TO_CHAR(E.HIRE_DATE, 'YYYY') AS YEAR
	 , TO_CHAR(E.HIRE_DATE, 'MM') AS MONTH
  FROM EMPLOYEES E
;
-- 81. 100번 사원의 모든 부하직원을 계층조회한다. 단, LEVEL이 4인 사원은 제외한다.
 SELECT LEVEL
 	  , E.EMPLOYEE_ID 
   FROM EMPLOYEES E
  WHERE LEVEL <= 4
  START WITH E.EMPLOYEE_ID = 100
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID
  ORDER BY LEVEL
;
-- 82. 많은 월급을 받는 10명을 조회한다.
SELECT EMPLOYEE_ID 
	 , SALARY 
  FROM (SELECT EMPLOYEE_ID 
			 , SALARY 
	      FROM EMPLOYEES
	     ORDER BY SALARY DESC)
 WHERE ROWNUM <= 10
;
-- 83. 가장 적은 월급을 받는 사원의 상사명, 부서명을 조회한다.
SELECT E.SALARY 
	 , CONCAT(E2.FIRST_NAME, E2.LAST_NAME) AS MANAGER_NAME
	 , D.DEPARTMENT_NAME 
  FROM (SELECT EMPLOYEE_ID 
			 , SALARY 
			 , MANAGER_ID
			 , DEPARTMENT_ID 
	      FROM EMPLOYEES
	     ORDER BY SALARY) E
 INNER JOIN EMPLOYEES E2
    ON E.MANAGER_ID = E2.EMPLOYEE_ID 
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 WHERE ROWNUM <= 10
;
-- 84. 많은 월급을 받는 사원 중 11번 째 부터 20번째를 조회한다.
--SELECT 
--  FROM EMPLOYEES E
SELECT EMPLOYEE_ID 
	 , SALARY 
  FROM (SELECT EMPLOYEE_ID 
			 , SALARY 
			 , ROWNUM AS RN
		  FROM (SELECT EMPLOYEE_ID 
					 , SALARY 
			      FROM EMPLOYEES
			     ORDER BY SALARY DESC)
		 WHERE ROWNUM <＝ 20)
 WHERE RN >= 11
;
-- 85. 가장 적은 월급을 받는 중 90번 째 부터 100번째를 조회한다.
SELECT EMPLOYEE_ID 
	 , SALARY 
  FROM (SELECT EMPLOYEE_ID 
			 , SALARY 
			 , ROWNUM AS RN
		  FROM (SELECT EMPLOYEE_ID 
					 , SALARY 
			      FROM EMPLOYEES
			     ORDER BY SALARY)
		 WHERE ROWNUM <＝ 100)
 WHERE RN >= 90
;
-- 86. 'PU_CLERK' 직무인 2번째 부터 5번째 사원의 부서명, 직무명을 조회한다.
-- ============================================================
SELECT E.EMPLOYEE_ID 
	 , D.DEPARTMENT_NAME 
	 , J.JOB_TITLE 
  FROM EMPLOYEES E
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 WHERE E.JOB_ID = 'PU_CLERK'
;
-- 87. 모든 사원의 정보를 직무 오름차순, 월급 내림차순으로 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 ORDER BY E.JOB_ID 
     , E.SALARY DESC
;
-- 88. 직무별 평균월급을 평균월급순으로 오름차순 정렬하여 조회한다.
SELECT AVG(E.SALARY ) AS AVG_SALARY
  FROM EMPLOYEES E
 GROUP BY E.JOB_ID 
 ORDER BY AVG_SALARY
;
-- 89. 부서별 평균월급을 내림차순 정렬하여 조회한다.
SELECT ROUND(AVG(E.SALARY )) AVG_SALARY
  FROM EMPLOYEES E
 GROUP BY E.DEPARTMENT_ID 
 ORDER BY AVG_SALARY DESC
;
-- 90. 이름의 첫 번째 글자별 평균월급을 조회한다.
SELECT SUBSTR(E.FIRST_NAME, 1, 1) NAME_OF_FIRST
	 , ROUND(AVG(E.SALARY)) AVG_SALARY
  FROM EMPLOYEES E
 GROUP BY SUBSTR(E.FIRST_NAME, 1, 1)
;
-- 91. 입사연도별 최소월급을 조회한다.
SELECT TO_CHAR(HIRE_DATE, 'YYYY') YEAR 
	 , MIN(SALARY)
  FROM EMPLOYEES
 GROUP BY TO_CHAR(HIRE_DATE, 'YYYY')
;
-- 92. 월별 최대월급 중 2번째 부터 4번째 데이터만 조회한다.
SELECT MONTH_DATE 
	 , MAX_SALARY 
  FROM (SELECT MONTH_DATE 
  			 , MAX_SALARY 
  			 , ROWNUM RM
		  FROM (SELECT TO_CHAR(HIRE_DATE, 'MM') MONTH_DATE
					 , MAX(SALARY) MAX_SALARY
				  FROM EMPLOYEES
				 GROUP BY TO_CHAR(HIRE_DATE, 'MM'))
		 WHERE ROWNUM <= 4)
 WHERE RM >= 2
;
-- 93. 직무명별 최소월급을 조회한다.
SELECT JOB_TITLE 
	 , MIN_SALARY 
  FROM JOBS
; 
-- 94. 부서명별 최대월급을 조회한다.
SELECT JOB_TITLE 
	 , MAX_SALARY 
  FROM JOBS
;
-- 95. 직무명, 부서명 별 사원 수, 평균월급을 조회한다.
-- =================================================================
SELECT J.JOB_TITLE 
     , D.DEPARTMENT_NAME 
	 , COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
	 , AVG(E.SALARY) AS AVG_SALARY
  FROM EMPLOYEES E
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID
 INNER JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY J.JOB_TITLE
     , D.DEPARTMENT_NAME 
;
-- 96. 도시별 사원 수를 조회한다.
SELECT COUNT(E.EMPLOYEE_ID) AS LOCATION_COUNT
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY D.LOCATION_ID
;
-- 97. 국가별 사원 수, 최대월급, 최소월급을 조회한다.
-- 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 여기까지 했음, 
SELECT COUNT(E.EMPLOYEE_ID) AS EMP_COUNT_BY_COUNTRY
	 , MAX(E.SALARY) AS MAX_SAL
	 , MIN(E.SALARY) AS MIN_SAL
--	 , E.EMPLOYEE_ID 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
	ON D.LOCATION_ID = L.LOCATION_ID
 GROUP BY L.COUNTRY_ID 
;
-- 98. 대륙별 사원 수를 대륙명으로 오름차순 정렬하여 조회한다.
SELECT R.REGION_NAME
	 , COUNT(E.EMPLOYEE_ID)
  FROM REGIONS R
 INNER JOIN COUNTRIES C
    ON R.REGION_ID = C.REGION_ID
 INNER JOIN LOCATIONS L
    ON C.COUNTRY_ID = L.COUNTRY_ID
 INNER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID
 INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 GROUP BY R.REGION_NAME 
 ORDER BY R.REGION_NAME
 ;
-- 99. 이름이나 성에 'A' 혹은 'a' 가 포함된 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.FIRST_NAME LIKE '%A%'
    OR E.FIRST_NAME LIKE '%a%'
    OR E.LAST_NAME LIKE '%A%'
    OR E.LAST_NAME LIKE '%a%'
;
-- 100. 국가별로 월급이 5000 이상인 사원의 수를 조회한다.
SELECT L.COUNTRY_ID
	 , COUNT(E.EMPLOYEE_ID)
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
 WHERE E.SALARY >= 5000
 GROUP BY L.COUNTRY_ID 
;
-- 101. 인센티브를 안받는 사원이 근무하는 도시를 조회한다.
SELECT DISTINCT L.CITY 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D 
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 INNER JOIN LOCATIONS L 
    ON D.LOCATION_ID = L.LOCATION_ID 
 WHERE E.COMMISSION_PCT IS NULL
;
-- 102. 인센티브를 포함한 월급이 10000 이상인 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE SALARY + (SALARY * NVL(COMMISSION_PCT, 0)) >= 10000
;
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM (SELECT EMPLOYEE_ID
			 , FIRST_NAME
			 , LAST_NAME
			 , EMAIL
			 , PHONE_NUMBER
			 , HIRE_DATE
			 , JOB_ID
			 , SALARY
			 , COMMISSION_PCT
			 , MANAGER_ID
			 , DEPARTMENT_ID
			 , SALARY + (SALARY * NVL(COMMISSION_PCT, 0)) AS TOTAL_SAL
		  FROM EMPLOYEES) 
 WHERE TOTAL_SAL >= 10000
;
-- 103. 가장 많은 부서가 있는 도시를 조회한다.
SELECT CITY 
  FROM (SELECT L.CITY
		  FROM LOCATIONS L
		 INNER JOIN DEPARTMENTS D
			ON L.LOCATION_ID = D.LOCATION_ID
		 GROUP BY L.CITY
		 ORDER BY COUNT(D.DEPARTMENT_ID) DESC)
 WHERE ROWNUM = 1
;
-- 104. 가장 많은 사원이 있는 부서의 국가명을 조회한다.
SELECT COUNTRY_NAME 
  FROM (SELECT C.COUNTRY_NAME
			 , COUNT(E.EMPLOYEE_ID)
		  FROM COUNTRIES C
		  LEFT OUTER JOIN LOCATIONS L
			ON C.COUNTRY_ID = L.COUNTRY_ID
		  LEFT OUTER JOIN DEPARTMENTS D
			ON L.LOCATION_ID = D.LOCATION_ID
		  LEFT OUTER JOIN EMPLOYEES E
			ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
		 GROUP BY C.COUNTRY_NAME, E.DEPARTMENT_ID
		 ORDER BY COUNT(E.EMPLOYEE_ID) DESC)
 WHERE ROWNUM = 1
;
-- 105. 우편번호가 5자리인 도시에서 근무하는 사원명, 부서명, 도시명, 우편번호를 조회한다.
SELECT E.LAST_NAME 
	 , D.DEPARTMENT_NAME 
	 , L.CITY 
	 , L.POSTAL_CODE 
  FROM LOCATIONS L
 INNER JOIN DEPARTMENTS D
	ON L.LOCATION_ID = D.LOCATION_ID
 INNER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 WHERE L.POSTAL_CODE LIKE '_____'
;
-- 106. 우편번호에 공백이 없는 도시에서 근무하는 사원의 이름, 부서명, 우편번호를 조회한다.
SELECT E.LAST_NAME 
	 , D.DEPARTMENT_NAME 
	 , L.POSTAL_CODE
  FROM LOCATIONS L
 INNER JOIN DEPARTMENTS D
	ON L.LOCATION_ID = D.LOCATION_ID
 INNER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 WHERE L.POSTAL_CODE NOT LIKE '% %'
;
-- 107. "주"가 없는 도시에서 근무하는 사원의 이름, 도시를 조회한다.
SELECT E.LAST_NAME 
	 , L.CITY 
  FROM LOCATIONS l 
  LEFT OUTER JOIN DEPARTMENTS D
	ON L.LOCATION_ID = D.LOCATION_ID
  LEFT OUTER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 WHERE L.STATE_PROVINCE IS NULL
   AND E.EMPLOYEE_ID IS NOT NULL
;
-- 108. 국가명이 6자리인 국가의 모든 정보를 조회한다.
SELECT C.COUNTRY_ID 
	 , C.COUNTRY_NAME 
	 , C.REGION_ID 
  FROM COUNTRIES C
 WHERE C.COUNTRY_NAME LIKE '______'
;
-- 109. 사원의 이름과 성을 이용해 EMAIL과 같은 값으로 만들어 조회한다.
SELECT SUBSTR(FIRST_NAME, 1, 1) || UPPER(SUBSTR(LAST_NAME, 1, 7))
	 , EMAIL 
  FROM EMPLOYEES
  ORDER BY LENGTH(LAST_NAME) DESC
;
-- 110. 모든 사원들의 이름을 10자리로 변환해 조회한다. 예> 이름 => "        이름"
SELECT LPAD(LAST_NAME, 10, ' ')
  FROM EMPLOYEES
;
-- 111. 모든 사원들의 성을 10자리로 변환해 조회한다. 예> 성 => "성         "
SELECT RPAD(FIRST_NAME, 10, ' ')
  FROM EMPLOYEES
;
-- 112. 109번 사원의 입사일 부터 1년 내에 입사한 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES 
 WHERE HIRE_DATE >= (SELECT HIRE_DATE
 					   FROM EMPLOYEES
 					  WHERE EMPLOYEE_ID = 109) 
   AND HIRE_DATE <= (SELECT ADD_MONTHS(HIRE_DATE, 12)
 					   FROM EMPLOYEES
 					  WHERE EMPLOYEE_ID = 109)
;
-- 113. 가장 먼저 입사한 사원의 입사일로부터 2년 내에 입사한사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE HIRE_DATE >= (SELECT MIN(HIRE_DATE )
 					   FROM EMPLOYEES) 
   AND HIRE_DATE <= (SELECT ADD_MONTHS(MIN(HIRE_DATE), 24)
 					   FROM EMPLOYEES)
;
-- 114. 가장 늦게 입사한 사원의 입사일 보다 1년 앞서 입사한 사원의 모든 정보를 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE HIRE_DATE >= (SELECT ADD_MONTHS(MAX(HIRE_DATE), -12)
 					   FROM EMPLOYEES) 
   AND HIRE_DATE <= (SELECT MAX(HIRE_DATE )
 					   FROM EMPLOYEES)
;
-- 115. 도시명에 띄어쓰기 " " 가 포함된 도시에서 근무중인 사원들의 부서명, 도시명, 사원명을 조회한다.
SELECT D.DEPARTMENT_NAME
	 , L.CITY
	 , E.LAST_NAME 
  FROM (SELECT LOCATION_ID 
  			 , CITY 
		  FROM LOCATIONS
		 WHERE CITY LIKE '% %') L
 INNER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID
 INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
;
-- 116. MOD 함수를 통해 사원번호가 홀수면 남자, 짝수면 여자 로 구분해 조회한다. MOD(값, 나눌값)
SELECT CASE WHEN MOD(EMPLOYEE_ID, 2) = 0 THEN '남자'
	   ELSE '여자' END AS GENDER
  FROM EMPLOYEES 
;
-- 117. '20230222' 문자 데이터를 날짜로 변환해 조회한다.(DUAL)
SELECT TO_DATE('20230222', 'YYYY-MM-DD')
  FROM DUAL
;
-- 118. '20230222' 문자 데이터를 'YYYY-MM' 으로 변환해 조회한다.(DUAL)
SELECT TO_CHAR(TO_DATE('20230222', 'YYYY-MM-DD'), 'YYYY-MM')
  FROM DUAL
;
-- 119. '20230222130140' 문자 데이터를 'YYYY-MM-DD HH24:MI:SS' 으로 변환해 조회한다. (DUAL)
SELECT TO_DATE('20230222130140', 'YYYY-MM-DD HH24:MI:SS')
  FROM DUAL
;
-- 120. '20230222' 날짜의 열흘 후의 날짜를 'YYYY-MM-DD' 으로 변환해 조회한다. (DUAL)
SELECT TO_DATE('20230222', 'YYYY-MM-DD') + 10
  FROM DUAL
;
-- 121. 사원 이름의 글자수 별 사원의 수를 조회한다.
SELECT LENGTH(LAST_NAME)
	 , COUNT(EMPLOYEE_ID)
  FROM EMPLOYEES
 GROUP BY LENGTH(LAST_NAME)
;
-- 122. 사원 성의 글자수 별 사원의 수를 조회한다.
SELECT LENGTH(FIRST_NAME)
	 , COUNT(EMPLOYEE_ID)
  FROM EMPLOYEES
 GROUP BY LENGTH(FIRST_NAME)
;
-- 123. 사원의 월급이 5000 이하이면 "사원", 7000 이하이면 "대리", 9000 이하이면 "과장", 그 외에는 임원 으로 조회한다.
SELECT EMPLOYEE_ID
	 , CASE WHEN SALARY <= 5000 THEN '사원'
			WHEN SALARY <= 7000 THEN '대리'
			WHEN SALARY <= 9000 THEN '과장'
			ELSE '임원' END 
  FROM EMPLOYEES
;
-- 124. 부서별 사원의 수를 조인을 이용해 다음과 같이 조회한다."부서명 (사원의 수)"
SELECT D.DEPARTMENT_NAME || ' (' || 
	   COUNT(E.EMPLOYEE_ID) || ')'
  FROM EMPLOYEES E
 RIGHT OUTER JOIN DEPARTMENTS D
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_NAME 
;
-- 125. 부서별 사원의 수를 스칼라쿼리를 이용해 다음과 같이 조회한다. "부서명 (사원의 수)"
SELECT D.DEPARTMENT_NAME || ' (' || 
	   (SELECT COUNT(E.EMPLOYEE_ID) 
          FROM EMPLOYEES E 
         WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) || ')'
 FROM DEPARTMENTS D
;
-- 126. 사원의 정보를 다음과 같이 조회한다. "사원번호 번 사원의 이름은 성이름 입니다."
SELECT EMPLOYEE_ID || 
	   '번 사원의 이름은 ' ||
	   FIRST_NAME || 
	   ' ' ||
	   LAST_NAME || 
	   '입니다.'
  FROM EMPLOYEES
;
-- 127. 사원의 정보를 스칼라쿼리를 이용해 다음과 같이 조회한다. "사원번호 번 사원의 상사명은 상사명 입니다."
SELECT E.EMPLOYEE_ID || 
       CASE WHEN E.MANAGER_ID IS NOT NULL THEN '번 사원의 상사명은 ' ||
                                               (SELECT FIRST_NAME || 
                                               		   ' ' || 
                                               		   LAST_NAME 
                                                FROM EMPLOYEES E2
                                                WHERE E.MANAGER_ID = E2.EMPLOYEE_ID) ||
                                               '입니다.'
            ELSE '의 상사는 없습니다.' 
       		END AS MANAGER
FROM EMPLOYEES E
;
-- 128. 사원의 정보를 조인을 이용해 다음고 같이 조회한다. "사원명 (직무명)"
SELECT E.FIRST_NAME ||
	   ' ' ||
	   E.LAST_NAME ||
	   ' (' ||
	   J.JOB_TITLE ||
	   ')' AS JOB_INFO
  FROM EMPLOYEES E
 INNER JOIN JOBS J
	ON E.JOB_ID = J.JOB_ID
;
-- 129. 사원의 정보를 스칼라쿼리를 이용해 다음과 같이 조회한다. "사원명 (직무명)"
SELECT FIRST_NAME ||
	   ' ' ||
	   LAST_NAME ||
	   ' (' ||
	   (SELECT JOB_TITLE
	      FROM JOBS J
	     WHERE E.JOB_ID = J.JOB_ID) ||
	   ')' AS JOB_INFO
  FROM EMPLOYEES E
;
-- 130. 부서별 월급 차이(최고월급 - 최저월급)가 가장 큰 부서명을 조회한다.
SELECT DEPARTMENT_NAME
  FROM (SELECT D.DEPARTMENT_NAME
			 , MAX(E.SALARY) - MIN(E.SALARY) AS SUB_SAL
		  FROM EMPLOYEES E
		 INNER JOIN DEPARTMENTS D
		    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
		 GROUP BY D.DEPARTMENT_NAME 
		 ORDER BY SUB_SAL DESC)
 WHERE ROWNUM = 1;
-- 131. 부서별 월급 차이(최고월급 - 최저월급)가 가장 큰 부서에서 근무하는 사원들의 직무명을 중복없이 조회한다.
SELECT DISTINCT J.JOB_TITLE
  FROM EMPLOYEES E
 INNER JOIN JOBS J 
	ON E.JOB_ID = J.JOB_ID
 WHERE E.DEPARTMENT_ID = (SELECT DEPARTMENT_ID
					        FROM (SELECT DEPARTMENT_ID
					                FROM EMPLOYEES
					               GROUP BY DEPARTMENT_ID
					               ORDER BY (MAX(SALARY) - MIN(SALARY)) DESC)
					       WHERE ROWNUM = 1)
;
-- 132. 부서장이 없는 부서명 중 첫 글자가 'C' 로 시작하는 부서명을 조회한다.
SELECT D.DEPARTMENT_NAME
  FROM DEPARTMENTS D
 WHERE D.MANAGER_ID IS NULL
   AND D.DEPARTMENT_NAME LIKE 'C%'
;
-- 133. 부서장이 있는 부서명 중 첫 글자가 'S' 로 시작하는 부서에서 근무중인 사원의 이름과 직무명, 부서명을 조회한다.
SELECT E.FIRST_NAME  
	 , E.LAST_NAME 
	 , DE.DEPARTMENT_NAME
  FROM EMPLOYEES E
 INNER JOIN (SELECT DEPARTMENT_ID  
 				  , DEPARTMENT_NAME 
			   FROM DEPARTMENTS
			  WHERE MANAGER_ID IS NOT NULL
			    AND DEPARTMENT_NAME LIKE 'S%') DE
	ON E.DEPARTMENT_ID = DE.DEPARTMENT_ID
;
-- 134. 지역변호가 1000 ~ 1999 사이인 지역내 부서의 모든 정보를 조회한다.
SELECT DEPARTMENT_ID
	 , DEPARTMENT_NAME
	 , MANAGER_ID
	 , LOCATION_ID
  FROM DEPARTMENTS D
 WHERE D.LOCATION_ID BETWEEN 1000 AND 1999
;
-- 135. 90, 60, 100번 부서에서 근무중인 사원의 이름, 성, 부서명을 조회한다.
SELECT E.LAST_NAME 
	 , E.FIRST_NAME 
	 , D.DEPARTMENT_NAME 
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 WHERE E.DEPARTMENT_ID IN (90, 60, 100)
;
-- 136. 부서명이 5글자 미만인 부서에서 근무중인 사원의 이름, 부서명을 조회한다.
SELECT E.LAST_NAME
	 , D.DEPARTMENT_NAME
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D 
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 WHERE D.DEPARTMENT_NAME NOT LIKE '____%'
;
-- 137. 국가 아이디가 'C'로 시작하는 국가의 지역을 모두 조회한다.
SELECT L.LOCATION_ID
	 , L.STREET_ADDRESS
	 , L.POSTAL_CODE
	 , L.CITY
	 , L.STATE_PROVINCE
	 , L.COUNTRY_ID
  FROM LOCATIONS L
 WHERE L.COUNTRY_ID LIKE 'C%'
;
-- 국가명이 'a'로 끝나는 국가의 모든 정보를 조회
SELECT C.COUNTRY_ID 
	 , C.COUNTRY_NAME 
	 , C.REGION_ID 
  FROM COUNTRIES C
 WHERE C.COUNTRY_NAME  LIKE '%a'
;
SELECT C.COUNTRY_ID 
	 , C.COUNTRY_NAME 
	 , C.REGION_ID 
  FROM COUNTRIES C
 WHERE C.COUNTRY_NAME NOT LIKE '%a'
;
-- 138. 국가 아이디의 첫 글자와 국가명의 첫 글자가 다른 모든 국가를 조회한다.
SELECT COUNTRY_NAME
  FROM (SELECT COUNTRY_NAME
			 , SUBSTR(COUNTRY_ID, 1, 1) AS ID_FIRST
			 , SUBSTR(COUNTRY_NAME, 1, 1) AS NAME_FIRST
		 FROM COUNTRIES)
 WHERE ID_FIRST != NAME_FIRST
;
-- 139. 사원 모든 정보 중 이메일만 모두 소문자로 변경하여 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , LOWER(EMAIL)
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
;
-- 140. 사원의 월급을 TRUNC(소수점 버림) 함수를 사용해 100 단위는 버린채 다음과 같이 조회한다. 예> 3700 -> 3000, 12700 -> 12000
SELECT TRUNC(SALARY, -3) AS TRUNC_SALARY
  FROM EMPLOYEES
;
-- 141. 100단위를 버린 사원의 월급 별 사원의 수를 조회한다.
SELECT TRUNC_SAL
	 , COUNT(1) AS COUNT_SAL
  FROM (SELECT TRUNC(SALARY, -3) AS TRUNC_SAL 
    	  FROM EMPLOYEES)
 GROUP BY TRUNC_SAL
 ORDER BY TRUNC_SAL
;
-- 142. 현재 시간으로부터 20년 전 보다 일찍 입사한 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
 WHERE E.HIRE_DATE < (TO_DATE(TO_CHAR(SYSDATE, 'YYYYMMDD') - 200000, 'YYYY-MM-DD'))
-- WHERE E.HIRE_DATE < ADD_MONTHS(SYSDATE, - 20 * 12)
;
SELECT TO_DATE(TO_CHAR(SYSDATE, 'YYYYMMDD') - 200000, 'YYYY-MM-DD')
	 , ADD_MONTHS(SYSDATE, - 20 * 12)
  FROM DUAL
;
-- 143. 부서번호별 현재 시간으로부터 15년 전 보다 일찍 입사한 사원의 수를 조회한다.
SELECT COUNT(E.EMPLOYEE_ID) 
  FROM EMPLOYEES E
 WHERE E.HIRE_DATE < (TO_DATE(TO_CHAR(SYSDATE, 'YYYYMMDD') - 150000, 'YYYY-MM-DD'))
;
-- 144. 부서명, 직무명 별 평균 월급을 조회한다.
SELECT AVG(E.SALARY)
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID
 GROUP BY D.DEPARTMENT_NAME, J.JOB_TITLE 
;
-- 145. 도시명, 지역명 별 사원의 수를 조회한다.
SELECT COUNT(E.EMPLOYEE_ID)
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
 INNER JOIN COUNTRIES C
    ON L.COUNTRY_ID = C.COUNTRY_ID
 INNER JOIN REGIONS R
    ON C.REGION_ID = R.REGION_ID
 GROUP BY L.CITY, R.REGION_NAME 
;
-- 146. 부서명, 직무명 별 평균 월급 중 가장 작은 평균월급을 받는 부서명, 직무명을 조회한다.
SELECT DEPARTMENT_NAME
	 , JOB_TITLE
	 , AVG_SAL
  FROM (SELECT D.DEPARTMENT_NAME
			 , J.JOB_TITLE
			 , AVG(E.SALARY) AS AVG_SAL
		  FROM EMPLOYEES E
		 INNER JOIN DEPARTMENTS D
			ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
		 INNER JOIN JOBS J
			ON E.JOB_ID = J.JOB_ID
		 GROUP BY D.DEPARTMENT_NAME, J.JOB_TITLE
		 ORDER BY AVG_SAL
)
WHERE ROWNUM = 1
;
-- 147. 102번 직원의 모든 부하직원의 수를 조회한다.
 SELECT COUNT(E.EMPLOYEE_ID)
   FROM EMPLOYEES E
  WHERE EMPLOYEE_ID != 102
  START WITH EMPLOYEE_ID = 102
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;
-- 148. 113번 직원의 모든 부하직원의 수를 조회한다.
 SELECT COUNT(E.EMPLOYEE_ID)
   FROM EMPLOYEES E
  WHERE EMPLOYEE_ID != 113
  START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;
SELECT EMPLOYEE_ID 
	 , MANAGER_ID 
  FROM EMPLOYEES 
 WHERE MANAGER_ID = 113
;
-- 149. 부하직원이 없는 사원의 모든 정보를 조회한다.
SELECT E.EMPLOYEE_ID
	 , E.FIRST_NAME
	 , E.LAST_NAME
	 , E.EMAIL
	 , E.PHONE_NUMBER
	 , E.HIRE_DATE
	 , E.JOB_ID
	 , E.SALARY
	 , E.COMMISSION_PCT
	 , E.MANAGER_ID
	 , E.DEPARTMENT_ID
  FROM EMPLOYEES E
  LEFT OUTER JOIN EMPLOYEES M 
    ON E.EMPLOYEE_ID = M.MANAGER_ID
 WHERE M.MANAGER_ID IS NULL;
-- 150. 사원번호가 100번인 사원의 사원번호, 이름과 사원번호로 내림차순 정렬된 사원의 사원번호, 이름 조회한다.
SELECT EMPLOYEE_ID 
	 , FIRST_NAME 
  FROM EMPLOYEES
 ORDER BY CASE WHEN EMPLOYEE_ID = 100 THEN 0 ELSE 1 END ASC
	 , EMPLOYEE_ID DESC
;
/*조회 예
--------------------
100    Steven
206    William
205    Shelley
204    Hermann
203    Susan
202    Pat
201    Michael
200    Jennifer
199    Douglas
198    Donald
197    Kevin
196    Alana
...
*/

-- 수행하는 직무의 이름이 Finance Manager인 사원의 사번, 직무 아이디 조회
SELECT E.EMPLOYEE_ID 
	 , E.JOB_ID 
  FROM EMPLOYEES E
 WHERE E.JOB_ID = (SELECT J.JOB_ID 
 					 FROM JOBS J
 					WHERE J.JOB_TITLE ='Finance Manager')
;